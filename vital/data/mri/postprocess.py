# -*- coding: utf-8 -*-
"""
postprocess.py
author: clement zotti (clement.zotti@usherbrooke.ca)
"""
import numpy as np
from scipy.ndimage.measurements import label
from skimage.morphology import convex_hull_image


class PostProcessing(object):
    """ This is the base class for all the post processing.
    """

    def __call__(self, img, *kwargs):
        """ All the postprocessing subclasses must override this method.
        It is called for the prediction part of this pipeline.

        Args:
            img: ndarray, data to post process.
            kwargs: additional parameters

        Returns:
            ndarray: data where post processing is applied.
        """
        if len(img.shape) == 4:
            img = np.squeeze(img, axis=3)
        return np.expand_dims(self.process_3d_image(img), axis=3)



class Post2dBigBlob(PostProcessing):
    """ This class finds the biggest blob over each slice of a 3d image an returns an image with only this
    blob.
    """

    @staticmethod
    def process_3d_image(img):
        """ Method to process the 3d image.

        Args:
            img: ndarray, The 3d label field.

        Returns:
            ndarray of the 3d label field postprocessed.
        """
        res = np.zeros_like(img)
        classes = np.unique(img.flat)
        for s in range(img.shape[0]):
            for c in range(1, len(classes)):
                timg = np.copy(img[s])
                timg[timg != c] = 0

                # Find each blob in the image
                lbl, num = label(timg)

                # Count the number of elements per label
                count = np.bincount(lbl.flat)
                if not np.any(count[1:]):
                    continue

                # Select the biggest label
                maxi = np.argmax(count[1:]) + 1

                # Filter the others
                lbl[lbl != maxi] = 0

                # Rescale the result
                lbl = np.clip(lbl, 0, 1)

                res[s] += lbl * c
                res[s][res[s] > c] = c
        return res


class Post3dBigBlob(PostProcessing):
    """ This class finds the largest blob in a 3D label field and returns an image with only this blob.
    """

    @staticmethod
    def process_3d_image(img):
        """ Method to process the 3d image.

        Args:
            img: ndarray, The 3d label field.

        Returns:
            ndarray of the 3d image postprocessed.
        """

        res = np.zeros_like(img)
        classes = np.unique(img.flat)
        for c in range(1, len(classes)):
            timg = np.copy(img)
            timg[timg != c] = 0

            # Find each blob in the image
            lbl, num = label(timg)

            # Count the number of elements per label
            count = np.bincount(lbl.flat)
            if not np.any(count[1:]):
                continue

            # Select the largest blob
            maxi = np.argmax(count[1:]) + 1

            # Remove the other blobs
            lbl[lbl != maxi] = 0

            # Rescale the result
            lbl = np.clip(lbl, 0, 1)

            res += lbl * c
            res[res > c] = c

        return res


class PostConvexHull(PostProcessing):
    """ Postprocessing consisting on computing a convexHull along the first
    dimension of an array.
    """

    @staticmethod
    def process_3d_image(img):
        """ Method to process the 3d image.

        Args:
            img: ndarray, The 3d binary label field.

        Returns:
            ndarray of the 3d image postprocessed.
        """
        res = np.zeros_like(img)
        for c in [1, 2, 3]:
            c_img = np.copy(img, order='C')
            c_img[c_img != c] = 0
            # Generate the convexhull for the first dimension of the np array
            # The convexhull is generated by slicing only if the slice is not
            # empty
            if c != 1:
                hull = np.array([convex_hull_image(c_img[s])
                                 if c_img[s].sum() else c_img[s]
                                 for s in range(c_img.shape[0])])
            else:
                hull = np.copy(c_img)
                hull = np.clip(hull, 0, 1)
            res += hull * c
            res[res > c] = c

        return res
