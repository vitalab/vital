from vital.utils.jobs.job import Job


class LocalJob(Job):
    """Class that can generate local shell job scripts and runs them sequentially."""

    RUN_CMD = "bash"

    def _build_script_str(self) -> str:
        sub_commands = []

        command = [
            "#!/bin/bash",
            "#",
            "# Auto-generated by vital (https://github.com/nathanpainchaud/vital)",
            "#################\n",
        ]
        sub_commands.extend(command)

        # add out output
        if self._enable_log_out:
            command = [
                "# a file for job output, you can check job progress",
                "exec 1<&-  # Close STDOUT file descriptor",
                f"exec 1>{self._save_dir / 'job_output.out'}",
                "#################\n",
            ]
            sub_commands.extend(command)

        # add err output
        if self._enable_log_err:
            command = [
                "# a file for errors",
                "exec 2<&-  # Close STDERR file descriptor",
                f"exec 2>{self._save_dir / 'job_output.err'}",
                "#################\n",
            ]
            sub_commands.extend(command)

        # add additional commands
        sub_commands.append("# user-defined setup before main task")
        for cmd in self._setup_options.get("commands", []):
            sub_commands.append(cmd)
        sub_commands.append("#################\n")

        # add run command
        sub_commands.append("# main task")
        sub_commands.append(f"python {self._setup_options['script']} {self._script_args}")
        sub_commands.append("#################\n")

        # build full command with empty lines in between
        script_str = "\n".join(sub_commands)
        return script_str
